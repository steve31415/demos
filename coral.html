<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Coral Growth Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: black;
        }
        canvas {
            display: block;
        }
        #overlay {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 14px;
            border-radius: 4px;
            white-space: pre;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="overlay"></div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let grid;
        let imageData;
        let pixelCount = 0;
        let animationId = null;

        // Timing tracking
        const overlay = document.getElementById('overlay');
        let timeSimulate = 0;
        let timePutImage = 0;
        let timeWaiting = 0;
        let lastFrameEnd = 0;

        function init() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }

            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            // Use Uint8Array for speed - one byte per pixel
            grid = new Uint8Array(width * height);

            // Create imageData for efficient pixel manipulation
            imageData = ctx.createImageData(width, height);
            // Initialize to black (alpha = 255)
            for (let i = 3; i < imageData.data.length; i += 4) {
                imageData.data[i] = 255;
            }

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, width, height);

            pixelCount = 0;
            timeSimulate = 0;
            timePutImage = 0;
            timeWaiting = 0;
            lastFrameEnd = performance.now();
            animate();
        }

        function hslToRgb(h, s, l) {
            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };

                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function setPixel(x, y) {
            const idx = x + y * width;
            grid[idx] = 1;

            // Calculate color - hue rotates once per 1000 pixels
            const hue = (pixelCount % 10000) / 10000;
            const [r, g, b] = hslToRgb(hue, 1, 0.5);

            const imgIdx = idx * 4;
            imageData.data[imgIdx] = r;
            imageData.data[imgIdx + 1] = g;
            imageData.data[imgIdx + 2] = b;
            imageData.data[imgIdx + 3] = 255;

            pixelCount++;
        }

        function slideDown() {
            // Slide grid down
            for (let y = height - 1; y > 0; y--) {
                for (let x = 0; x < width; x++) {
                    grid[x + y * width] = grid[x + (y - 1) * width];
                }
            }
            // Clear top row
            for (let x = 0; x < width; x++) {
                grid[x] = 0;
            }

            // Slide imageData down
            const rowSize = width * 4;
            for (let y = height - 1; y > 0; y--) {
                const destOffset = y * rowSize;
                const srcOffset = (y - 1) * rowSize;
                for (let i = 0; i < rowSize; i++) {
                    imageData.data[destOffset + i] = imageData.data[srcOffset + i];
                }
            }
            // Clear top row in imageData (set to black)
            for (let i = 0; i < rowSize; i += 4) {
                imageData.data[i] = 0;
                imageData.data[i + 1] = 0;
                imageData.data[i + 2] = 0;
                imageData.data[i + 3] = 255;
            }
        }

        function simulateParticle() {
            // Start at random point in top row
            let x = Math.floor(Math.random() * width);
            let y = 0;

            while (true) {
                const rand = Math.random();
                let nx = x, ny = y;

                if (rand < 0.25) {
                    // Move left (wrap around)
                    nx = (x - 1 + width) % width;
                } else if (rand < 0.50) {
                    // Move right (wrap around)
                    nx = (x + 1) % width;
                } else if (rand < 0.70) {
                    // Move up
                    ny = y - 1;
                } else {
                    // Move down
                    ny = y + 1;
                }

                // Check boundaries and halt conditions
                if (ny < 0) {
                    // Would go off top - don't move
                    continue;
                }

                if (ny >= height) {
                    // Would go off bottom - halt here
                    break;
                }

                // Check if destination is occupied
                if (grid[nx + ny * width]) {
                    // Occupied - halt at current position
                    break;
                }

                // Move to new position
                x = nx;
                y = ny;
            }

            // Set pixel at halt location
            setPixel(x, y);

            // Check if in top 1/3
            if (y < height / 3) {
                slideDown();
            }
        }

        function animate() {
            const frameStart = performance.now();
            timeWaiting += frameStart - lastFrameEnd;

            // Process multiple particles per frame for speed
            const particlesPerFrame = Math.max(1, Math.floor(width / 50)) * 20;

            const simStart = performance.now();
            for (let i = 0; i < particlesPerFrame; i++) {
                simulateParticle();
            }
            timeSimulate += performance.now() - simStart;

            // Draw the updated image
            const putStart = performance.now();
            ctx.putImageData(imageData, 0, 0);
            timePutImage += performance.now() - putStart;

            // Update overlay
            const total = timeSimulate + timePutImage + timeWaiting;
            if (total > 0) {
                const pctSimulate = Math.round(100 * timeSimulate / total);
                const pctPutImage = Math.round(100 * timePutImage / total);
                const pctWaiting = Math.round(100 * timeWaiting / total);
                overlay.textContent =
                    `simulate: ${pctSimulate}%\n` +
                    `putImage: ${pctPutImage}%\n` +
                    `waiting:  ${pctWaiting}%`;
            }

            lastFrameEnd = performance.now();
            animationId = requestAnimationFrame(animate);
        }

        window.addEventListener('resize', init);
        init();
    </script>
</body>
</html>
